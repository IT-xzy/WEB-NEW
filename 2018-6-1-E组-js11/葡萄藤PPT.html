<!DOCTYPE html>
<!-- saved from url=(0091)file:///C:/Users/LALH/Desktop/PPT%20-%20%E5%89%AF%E6%9C%AC/PPT/console%20and%20debug.html#/ -->
<html class=" js no-mobile desktop no-ie chrome chrome62 c:-section users-section lalh-section desktop-section ppt%20-%20%e5%89%af%e6%9c%ac-section ppt-section w-1366 gt-240 gt-320 gt-480 gt-640 gt-768 gt-800 gt-1024 gt-1280 lt-1440 lt-1680 lt-1920 no-portrait landscape gradient rgba opacity textshadow multiplebgs boxshadow borderimage borderradius cssreflections csstransforms csstransitions no-touch no-retina fontface domloaded" id="console%20and%20debug-page"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="./葡萄藤PPT_files/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="./葡萄藤PPT_files/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="./葡萄藤PPT_files/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? '../css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script><link rel="stylesheet" type="text/css" href="./葡萄藤PPT_files/paper.css"><script type="text/javascript" src="./葡萄藤PPT_files/marked.js.下载"></script><script type="text/javascript" src="./葡萄藤PPT_files/markdown.js.下载"></script><script type="text/javascript" src="./葡萄藤PPT_files/notes.js.下载"></script><script type="text/javascript" src="./葡萄藤PPT_files/highlight.js.下载"></script>
</head>
<body>
<img src="./葡萄藤PPT_files/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com/" alt="" target="_blank">
</map>
<div class="reveal slide center" role="application" data-transition-speed="default" data-background-transition="fade">
    <div class="slides" style="width: 960px; height: 700px; left: 50%; top: 50%; bottom: auto; right: auto; transform: translate(-50%, -50%) scale(0.768857);">
        <section class="present" style="top: 133px; display: block;">
          <h2>【JS-11】<span style="text-transform:lowercase">当我们输入URL，按下回车发生了什么？</span></h2>
            <h3>小课堂</h3>
            <p>分享人:陈丹婷</p>
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 3px; display: block;">
            <p>目录</p>
            <!-- <p>1.背景介绍</p>            -->
            <p>1.具体执行的操作</p>
            <p>2.编码实战</p>
            <p>3.更多讨论</p>
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 267px; display: block;">
            <h3>1.具体执行的操作</h3>
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
            <h4>当我们输入URI，按下回车发生了什么？</h4>
            <p>回车键按下</p>
            <p>解析URL</p>
            <p>检查 HSTS 列表</p>
            <p>>DNS查询</p>
            <p>TCP连接的建立（三次握手）</p>
            <p></p>
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
            <h3>2.编码实战</h3>
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
               <h3>输入的是 URL 还是搜索的关键字？</h3>
            <h4 style="text-align: center;"> 

        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
              <!-- <p style="text-align: left;">var定义的aa,bb以及function定义的AA(),BB()都会被变量提升到window对象下面</p>
            <pre>            <code class="hljs php">
<span class="hljs-keyword">if( false ){
    var aa = 20;
    var bb = 30;
}
function AA(){};
function BB(){};</span> -->
<!-- <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">var</span> bName=<span class="hljs-string">"意大利炮"</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerSay</span><span class="hljs-params">()</span></span>{
        alert(bName);
    } -->
<!--     innerSay();
}
alert(aName); <span class="hljs-comment">//二营长</span>
alert(bName); <span class="hljs-comment">//脚本错误</span>
doSomething(); <span class="hljs-comment">//意大利炮</span>
innerSay() <span class="hljs-comment">//脚本错误</span> -->
            <!-- </code> -->
            <!-- </pre> -->
        <!-- </section> -->
       <!--  <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
             <p style="text-align: left;">(2)所有末定义直接赋值的变量自动声明为拥有全局作用域，例如：</p>
            <pre>            <code class="hljs php">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>{
    bName=<span class="hljs-string">"张大彪"</span>;
    alert(bName)
}
alert(bName); <span class="hljs-comment">//张大彪</span>
            </code>
            </pre>
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
           <p>(3)所有window对象的属性拥有全局作用域</p>
            <p style="text-align: left;">一般情况 --><!-- 下，window对象的内置属性都都拥有全局作用域，例如window.name、window.top等等。</p>
        </section> -->
        <!-- <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;"> -->
           <!-- <p>2. 函数声明与函数表达式在预解析的区别</p>
            <p style="text-align: center;">首先，我们知道解析器会对function定义的函数（也就是函数声明）在代码开始执行之前对其实行函数声明提升（function declaration hoisting），所以在函数声明之前调用该函数是不会在执行期间报错，但是函数表达式不同，函数表达式用 var 声明，也就是说解析器会对其变量提升，并对其赋值为undefined，然后在执行期间，等到执行到该var 变量的时候再将其变量指向一个function函数，所以在函数表达式之前执行该函数是会报错的。</p>
            <pre><code class="hljs php">
            <span class="hljs-keyword">
                AA();
                function AA(){};
                BB();
                var BB = function(){};
            </span>
            </code></pre>
        </section> -->
         <!-- <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
           <p>3. function 覆盖</p>
            <p style="text-align: center;">若定义了两个同名的函数，则在预解析期间后面一个会覆盖签名一个。</p>
            <pre><code class="hljs php">
            <span class="hljs-keyword">
                AA();   // 输出 
                function AA(){
                    console.log('I am AA_1');
                };
                AA();  // 输出 
                function AA(){
                    console.log('I am AA_2');
                }
            </span>
            </code></pre>
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
           <p>4. 预解析把变量或函数解析到其运行时的环境中</p>
            <p style="text-align: center;">解析器将变量提升并不是将所有的变量都提升到window对象下面，其提升的原则是提升到变量运行的环境中去。</p>
            <pre><code class="hljs php">
            <span class="hljs-keyword">
                这里 aa 被变量提升，但是aa 没有被变量提升到 window下面，而是被提升到其运行的环境 (function(){ })() 中去，也就是等同于
                aa =  "I am aa";
                (function(){
                    var aa;  
                    console.log(aa);  // 输出 aa 是 undefined
                    aa = "I am aa in a function";
                    console.log(aa);  //输出 aa 是 I am aa in a function
                })();
            </span>
            </code></pre>
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
           <p>5. var 变量提升以及 function 函数声明提升</p>
            <p style="text-align: center;">该点是对函数声明以及函数表达式进一步的说明，其实前面函数声明和函数表达式在预解析的不同表现，其主要的原因就是 var 和 function 两者不同的提升。这个问题从解析阶段到运行阶段来说明。首先，在解析阶段 var 后面的 AA 会被提升然后 AA 被定义为undefined，BB 也会被提升，而BB被提升后的内容就是整个 function 里面的内容，其实从浏览器的控制台我们可以看出一二。然后，整个解析过程完了就到了运行阶段，在运行阶段期间，当读到 AA() 的时候，其实就是将 AA 这个变量指向function(){}这个函数然后调用，而到了 BB() 的时候，就会从之前声明的函数中去查找该早已经声明的函数，然后直接调用。</p>
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
            <p style="text-align: center;">这个例子就很好说明了 var 在运行阶段动态内建，而 function 在预解析阶段静态建立。</p>
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
            <h3>3.编码实战</h3>
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;"> -->
            <!-- <h3>3.更多讨论</h3> -->
        <!-- </section> -->
       <!--  <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
              <p style="text-align: left;">例如下列代码中的bName和函数innerSay都只拥有局部作用域：</p>
            <pre>            <code class="hljs php">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">var</span> bName=<span class="hljs-string">"李云龙"</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerSay</span><span class="hljs-params">()</span></span>{
        alert(bName);
    }
    innerSay();
}
alert(bName); <span class="hljs-comment">//脚本错误</span>
innerSay(); <span class="hljs-comment">//脚本错误</span>
            </code>
            </pre>
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
             <p style="text-align: left;">闭包</p>
            如何从外部读取局部变量？
            出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。
            那就是在函数的内部，再定义一个函数。
            <pre>            <code class="hljs php">
                　<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>{
                　　　　<span class="hljs-keyword">var</span> n=<span class="hljs-number">999</span>;
                　　　　<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>{
                　　　　　　alert(n); <span class="hljs-comment">// 999</span>
                　　　　}
                　　}
            </code>
            </pre>
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
            <p style="text-align: left;">闭包</p>
            在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的"链式作用域"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。
            既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
           <pre>            <code class="hljs nimrod">
                　function f1(){
                　　　　<span class="hljs-keyword">var</span> n=<span class="hljs-number">999</span>;
                　　　　function f2(){
                　　　　　　alert(n);
                　　　　}
                　　　　<span class="hljs-keyword">return</span> f2;
                　　}
                　　<span class="hljs-keyword">var</span> <span class="hljs-literal">result</span>=f1();
                　　<span class="hljs-literal">result</span>(); // <span class="hljs-number">999</span>
            </code>
            </pre>
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
           <p style="text-align: left;">闭包的概念</p>
            闭包就是能够读取其他函数内部变量的函数。
            由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。
            所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
            <p style="text-align: left;">闭包的注意点</p>
            1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
            2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。
        </section> -->
      <!--   <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
            <h3>7.参考文献</h3>
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
            <p><a href="http://blog.163.com/zhangmihuo_2007/blog/static/27011075201452522824347/" target="_blank">月上西楼博客</a></p>
            <p><a href="http://ms.csdn.net/geek/67969?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" title="">w3school</a>博客</p>
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
            <h3>8.更多讨论</h3>
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
            <p></p>
        </section> -->
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
            <h4>鸣谢</h4>
            <p>感谢大家观看</p>
            <!-- <p><small>BY : 沁修 | 王义山</small></p> -->
        </section>

    </div>
<div class="backgrounds"><div class="slide-background present" data-loaded="true" style="display: block;"></div><div class="slide-background future" data-loaded="true" style="display: block;"></div><div class="slide-background future" data-loaded="true" style="display: block;"></div><div class="slide-background future" style="display: none;"></div><div class="slide-background future" style="display: none;"></div><div class="slide-background future" style="display: none;"></div><div class="slide-background future" style="display: none;"></div><div class="slide-background future" style="display: none;"></div><div class="slide-background future" style="display: none;"></div><div class="slide-background future" style="display: none;"></div><div class="slide-background future" style="display: none;"></div><div class="slide-background future" style="display: none;"></div><div class="slide-background future" style="display: none;"></div><div class="slide-background future" style="display: none;"></div><div class="slide-background future" style="display: none;"></div><div class="slide-background future" style="display: none;"></div><div class="slide-background future" style="display: none;"></div><div class="slide-background future" style="display: none;"></div><div class="slide-background future" style="display: none;"></div><div class="slide-background future" style="display: none;"></div><div class="slide-background future" style="display: none;"></div></div><div class="progress" style="display: block;"><span style="width: 0px;"></span></div><aside class="controls" style="display: block;"><button class="navigate-left" aria-label="previous slide"></button><button class="navigate-right enabled" aria-label="next slide"></button><button class="navigate-up" aria-label="above slide"></button><button class="navigate-down" aria-label="below slide"></button></aside><div class="slide-number" style="display: none;"></div><div class="speaker-notes" data-prevent-swipe=""></div><div class="pause-overlay"></div><div id="aria-status-div" aria-live="polite" aria-atomic="true" style="position: absolute; height: 1px; width: 1px; overflow: hidden; clip: rect(1px 1px 1px 1px);">
           
            分享人：陈丹婷
        </div></div>

<script src="./葡萄藤PPT_files/head.min.js.下载"></script>
<script src="./葡萄藤PPT_files/reveal.js.下载"></script>

<script>
    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
    // 	loop: false, // 是否循环演示
    // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
    // 	fragments: true, // 全局开启和关闭碎片。
    // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
    // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
    // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
    // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
    // }
    // 初始化幻灯片
    Reveal.initialize({
        history: true,
        dependencies: [
            { src: '../plugin/markdown/marked.js' },
            { src: '../plugin/markdown/markdown.js' },
            { src: '../plugin/notes/notes.js', async: true },
            { src: '../plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
    });
</script>


Contact GitHub API Training Shop Blog About
© 2016 GitHub, Inc. Terms Privacy Security Status He</body></html>