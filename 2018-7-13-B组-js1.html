<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="./css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="./css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="./lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? './css/reveal/print/pdf.css' :
            '../css/reveal/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
    <style>
        .reveal pre code {
            background-color: #120;
        }
    </style>
</head>

<body>
<img src="./img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com/" alt="" target="_blank">
</map>
<div class="reveal slide center" role="application" data-transition-speed="default" data-background-transition="fade">
    <div class="slides"
         style="width: 9.6rem; height: 7rem; left: 50%; top: 50%; bottom: auto; right: auto; transform: translate(-50%, -50%) scale(0.461571);">
        <section class="past" style="top: .87rem; display: none;" hidden="" aria-hidden="true">
            <h4>【JS-01】</h4>
            <h4>主题：简述JS中执行环境与作用域的关系？</h4>
            <h5>小课堂【深圳】</h5>
            分享人：陈皓宇
        </section>
        <section style="line-height: .7rem; top: 0; display: none;" class="past" hidden="" aria-hidden="true">
            目录
            <p>
                1.背景介绍
            </p>
            <p>
                2.知识剖析
            </p>
            <p>
                3.常见问题
            </p>
            <p>
                4.解决方案
            </p>
            <p>
                5.编码实战
            </p>
            <p>
                6.扩展思考
            </p>
            <p>
                7.参考文献
            </p>
            <p>
                8.更多讨论
            </p>
        </section>
        <section class="stack past" style="top: 0rem; display: none;" data-previous-indexv="1" hidden=""
                 aria-hidden="true">
            <section class="past" style="top: 2.665rem; display: none;" hidden="" aria-hidden="true">
                <h3>1.背景介绍</h3>
            </section>
            <section class="" style="top: 1.065rem; display: none;" aria-hidden="true">
                <h5>什么是执行环境？</h5>
                <p>
                    执行环境（execution context，为简单起见，有时也称为“环境”）是JavaScript 中最为重要的一个概念。
                    执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。——《JavaScript高级程序设计（第3版）》
                </p>
            </section>
        </section>
        <section class="stack past" style="top: 0rem; display: none;" data-previous-indexv="0" hidden=""
                 aria-hidden="true">
            <section class="" style="top: 2.665rem; display: none;" aria-hidden="true">
                <h3>2.知识剖析</h3>
            </section>
            <section class="future" aria-hidden="true" hidden="" style="top: .515rem; display: none;">
                <h5>每个函数都有一个自己的执行环境。</h5>
                <p>某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）</p>
            </section>
            <section class="future" aria-hidden="true" hidden="" style="top: .515rem; display: none;">
                <p>
                    变量对象
                </p>
                <P style="text-align: left">
                    每个执行环境都有一个与之关联的变量对象（variable
                    object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。函数的又称为活动对象（activation
                    object）——《JS3》
                </P>
            </section>
            <section>
                <p style="text-align: justify">
                    个人的理解的作用域:<br>
                    就是[[scope]],每个js的函数都是一个对象，对象中有写属性我们可以访问，有些不行；
                    js引擎存取的[[scope]]就是其中一个；它就是作用域，存储了执行期的上下文的集合；
                </p>
            </section>
            <section class="future" aria-hidden="true" hidden="" style="top: .515rem; display: none;">
                <p>
                    作用域链
                </p>
                <P style="text-align: left">
                    当代码进入到某个执行环境，准备执行时，
                    会为该执行环境对应的变量对象创建一个作用域链。
                    作用域链其实就相当于一个变量对象的集合，
                    其第一个元素是当前执行环境的变量对象，
                    最后一个元素是全局执行环境的变量对象（在浏览器中即window对象）。</P>
            </section>
            <section>
                <p style="text-align: justify">个人的理解作用域链：<br>
                    [[scope]]中所存储的执行上下文对象的集合，这个集合呈链式链接，把这种链式链接叫作用域链；
                </p>
            </section>
            <section class="future" aria-hidden="true" hidden="" style="top: .515rem; display: none;">
                <p>
                    标识符查询
                </p>
                <P style="text-align: left">标识符解析是沿着作用域链一级一级地搜索标识符的过程。——《J3》。</P>
                <P style="text-align: left">
                    标识符解析,其实就是查找变量（包括函数定义）。而且这个查找过程是按照作用域链的顺序走的，也就是先搜索当前执行环境的变量对象，找到就终止，没找到就继续搜索上一层执行环境的变量对象，一直搜索到顶层的window对象。</P>
            </section>
            <section class="future" aria-hidden="true" hidden="" style="top: .515rem; display: none;">
                <p>
                    tip:
                </p>
                <P style="text-align: left">ES5只有函数作用域和全局作用域，并没有块级作用域。但ES6中有块级作用域</P>
            </section>
            <section style="width: 110%; top: 3.3rem; display: none;" class="future" aria-hidden="true" hidden="">
                <p>看着很拗口，我们后面看看demo</p>
            </section>
            <section style="width: 110%; top: 3.3rem; display: none;" class="future" aria-hidden="true" hidden="">

                <img src="img/2018-4-30-b/one.png" width="500px" alt="">
            </section>
            <section style="width: 110%; top: 3.3rem; display: none;" class="future" aria-hidden="true" hidden="">
                <img src="img/2018-4-30-b/two.png" width="900px" alt="">
            </section>
        </section>
        <section class="stack past" style="top: 0; display: none;" data-previous-indexv="1" hidden=""
                 aria-hidden="true">

            <section class="stack past" style="top: 0; display: none;" data-previous-indexv="0" hidden=""
                     aria-hidden="true">
                <section class="" style="top: 2.665rem; display: none;" aria-hidden="true">
                    <h3>3.常见问题</h3>
                </section>
                <p>在ES5中没有块级作用域,具体指的什么？ES6的块级作用域又有哪些表现?</p>
                <code>
                    for(var i=0;i<5;i++){
                    console.log(i);
                    }
                    console.log(i);
                </code>
                <br>
                <code>
                    if(true){
                    var color='red';
                    }
                    console.log(color);
                </code>
                <p>打开IDE...</p>
            </section>
            <section style="width: 110%; top: 3.3rem; display: none;" class="future" aria-hidden="true" hidden="">
                <p>
                    如果是在Java、C语言中，上面的i会在for语句执行完后就被销毁，但在JavaScript中，for语句中的变量声明会将变量添加到当前的执行环境（if语句也是），这里就是全局环境，所以即使是for循环执行完了，变量i也会存在循环外部的执行环境中。
                </p>
            </section>
            <section style="width: 110%; top: 3.3rem; display: none;" class="future" aria-hidden="true" hidden="">
                <p style="">为什么需要块级作用域?</p>

            </section>
            <section style="width: 110%; top: 3.3rem; display: none;" class="future" aria-hidden="true" hidden="">
                <p>
                    1、内层变量可能会覆盖外层变量
                </p>
                <p>
                    2、用来记数的循环变量，可能会泄露为全局变量
                </p>
            </section>
            <section style="width: 110%; top: 3.3rem; display: none;" class="future" aria-hidden="true" hidden="">
                <p style="">块级作用域的表现</p>
                <p>1、允许任意多个块级作用域的嵌套，而且外层作用域无法读取内层作用域的变量</p>
                <p>2、内层作用域可以定义外层作用域的同名变量</p>
                <p>3、可以让ES5中得到广泛应用IIFE(立即执行函数退休)</p>
            </section>

        </section>
        </section>

        <section class="stack past" style="top: 0rem; display: block;" data-previous-indexv="0" hidden=""
                 aria-hidden="true">
            <section class="" style="top: 2.665rem; display: block;" aria-hidden="true">
                <h3>5.编码实战</h3>
            </section>
        </section>
        <section class="stack past" style="top: 0rem; display: block;" data-previous-indexv="0" hidden=""
                 aria-hidden="true">
            <section class="" style="top: 2.665rem; display: block;" aria-hidden="true">
                <h3>6.扩展思考</h3>
            </section>
            <section class="future" aria-hidden="true" hidden="" style="top: 2.435rem; display: block;">
                <p>执行环境和作用域是一回事吗？</p>
            </section>
            <section class="future" aria-hidden="true" hidden="" style="top: 2.435rem; display: block;">
                <p>
                    作用域和执行环境是两个完全不同的概念，我们试图给他俩分别一个明确的定义，发现很难，因为你很难定义一个概念“是什么”，但是我们可以搞清楚他们分别起什么作用。另一个令人迷惑的地方就是js中的this关键字。其实执行环境就是this的值。总的来说，作用域是相对于函数来讲的，因为ES5
                    里没有块级作用域，只有函数才能形成新的作用域。而且作用域在函数声明时就定义好了。作用域里声明的变量和函数，外部无法访问，注意，是外部。而执行环境在函数被调用时才生成。</p>
            </section>
            <section class="future" aria-hidden="true" hidden="" style="top: 2.435rem; display: block;">
                <p>函数作用域中的变量一定访问不到？即局部变量访问不到吗？</p>
            </section>
            <section class="future" aria-hidden="true" hidden="" style="top: 2.435rem; display: block;">
                <p>按道理说，局部变量在全局环境中访问不到的，
                    <mark>但是</mark>
                    闭包的出现打破了这个定律
                </p>
                <p>请看代码示例：</p>
            </section>

        </section>
        <section class="stack present" style="top: 0rem; display: block;" data-previous-indexv="0">
            <section class="present" style="top: 2.665rem; display: block;">
                <h3>7.参考文献</h3>
            </section>
            <section class="future" aria-hidden="true" hidden="" style="top: 2.335rem; display: block;">
                <p>
                    参考一：JS高程
                </p>
                <p>
                    参考二：ES6块级作用域部分
                </p>
                <p>
                    参考三：《head first》
                </p>
            </section>
        </section>
        <section class="stack future" style="top: 0rem; display: block;" data-previous-indexv="0" hidden=""
                 aria-hidden="true">
            <section class="" style="top: 2.665rem; display: block;" aria-hidden="true">
                <h3>8.更多讨论</h3>
                <p>块级作用的缺点在哪里？</p>
            </section>
            <section class="future" aria-hidden="true" hidden="" style="top: 2.435rem; display: block;">
                块级作用域，对javascript是一个巨大提升，但是它也有一个显而易的缺点，就是块级作用域没有返回值。
                本质上块级作用域是一个语句，将多个操作封装在一起，没有返回值。
                <br>
                <code>
                    {
                    let a=1;
                    a++;
                    }
                </code>
                <p>
                    上面的代码中，块级作用域将两个语句封装在一起，但是在块级作用外，没有办法得到a的值，因为块级作用域不返回值，除非a是全局变量。
                </p>
            </section>
            <section class="future" aria-hidden="true" hidden="" style="top: 2.435rem; display: block;">
                <p>
                    如何解决呢？
                </p>
                <p>
                    现在有一个提案，是的块级作用域可以变成表达式，既可以返回值，办法就是在块级作用域之前加上do，是他变成do表达式。

                </p>
                <code>
                    let x=
                    <mark>do</mark>
                    {
                    let a=1;
                    a++;
                    }
                </code>
                <p>上述代码中，变量x会得到整个块级作用域的返回值.</p>
            </section>
            <section class="" style="top: 2.665rem; display: block;" aria-hidden="true">
                <p>最后的最后的套论</p>
                <p>如何延长作用域链</p>
                <p>try-catch语句</p>
                <p>with语句</p>
                <p>try/catch/finally 语句用于处理代码中可能出现的错误信息。用的较少，不做过多介绍了</p>

            </section>
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 2.24rem; display: block;">
            <h4>鸣谢</h4>
            <h4>感谢大家观看</h4>
            <small>BY : 杨亚洲|陈皓宇</small>
        </section>
    </div>
    <div class="backgrounds">
        <div class="slide-background past" data-loaded="true" style="display: none;"></div>
        <div class="slide-background past" data-loaded="true" style="display: none;"></div>
        <div class="slide-background stack past" data-loaded="true" style="display: none;">
            <div class="slide-background past" data-loaded="true" style="display: none;"></div>
            <div class="slide-background present" data-loaded="true" style="display: none;"></div>
        </div>
        <div class="slide-background stack past" data-loaded="true" style="display: none;">
            <div class="slide-background present" data-loaded="true" style="display: none;"></div>
            <div class="slide-background future" data-loaded="true" style="display: none;"></div>
            <div class="slide-background future" data-loaded="true" style="display: none;"></div>
            <div class="slide-background future" style="display: none;"></div>
            <div class="slide-background future" style="display: none;"></div>
            <div class="slide-background future" style="display: none;"></div>
            <div class="slide-background future" style="display: none;"></div>
            <div class="slide-background future" style="display: none;"></div>
            <div class="slide-background future" style="display: none;"></div>
        </div>
        <div class="slide-background stack past" data-loaded="true" style="display: none;">
            <div class="slide-background present" data-loaded="true" style="display: none;"></div>
        </div>
        <div class="slide-background past" data-loaded="true" style="display: none;"></div>
        <div class="slide-background stack past" data-loaded="true" style="display: none;">
            <div class="slide-background present" data-loaded="true" style="display: none;"></div>
            <div class="slide-background future" data-loaded="true" style="display: none;"></div>
            <div class="slide-background future" data-loaded="true" style="display: none;"></div>
            <div class="slide-background future" style="display: none;"></div>
            <div class="slide-background future" style="display: none;"></div>
            <div class="slide-background future" style="display: none;"></div>
            <div class="slide-background future" style="display: none;"></div>
            <div class="slide-background future" style="display: none;"></div>
            <div class="slide-background future" style="display: none;"></div>
            <div class="slide-background future" style="display: none;"></div>
            <div class="slide-background future" style="display: none;"></div>
        </div>
        <div class="slide-background stack past" data-loaded="true" style="display: block;">
            <div class="slide-background present" data-loaded="true" style="display: block;"></div>
        </div>
        <div class="slide-background stack past" data-loaded="true" style="display: block;">
            <div class="slide-background present" data-loaded="true" style="display: block;"></div>
            <div class="slide-background future" data-loaded="true" style="display: block;"></div>
            <div class="slide-background future" data-loaded="true" style="display: none;"></div>
        </div>
        <div class="slide-background stack present" data-loaded="true" style="display: block;">
            <div class="slide-background present" data-loaded="true" style="display: block;"></div>
            <div class="slide-background future" data-loaded="true" style="display: block;"></div>
        </div>
        <div class="slide-background stack future" data-loaded="true" style="display: block;">
            <div class="slide-background present" data-loaded="true" style="display: block;"></div>
        </div>
        <div class="slide-background future" data-loaded="true" style="display: block;"></div>
    </div>
    <div class="progress" style="display: block;">
        <span style="width: 6.77273rem;"></span>
    </div>
    <aside class="controls" style="display: block;">
        <button class="navigate-left enabled" aria-label="previous slide"></button>
        <button class="navigate-right enabled" aria-label="next slide"></button>
        <button class="navigate-up" aria-label="above slide"></button>
        <button class="navigate-down enabled" aria-label="below slide"></button>
    </aside>
    <div class="slide-number" style="display: none;"></div>
    <div class="speaker-notes" data-prevent-swipe=""></div>
    <div class="pause-overlay"></div>
    <div id="aria-status-div" aria-live="polite" aria-atomic="true"
         style="position: absolute; height: .01rem; width: .01rem; overflow: hidden; clip: rect(.01rem .01rem .01rem .01rem);">
        7.参考文献
    </div>
</div>

<script src="./lib/reveal/js/head.min.js"></script>
<script src="./lib/reveal/reveal.js"></script>

<script>
    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
    // 	loop: false, // 是否循环演示
    // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
    // 	fragments: true, // 全局开启和关闭碎片。
    // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
    // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
    // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
    // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
    // }
    // 初始化幻灯片
    Reveal.initialize({
        history: true,
        dependencies: [{
            src: './plugin/markdown/marked.js'
        },
            {
                src: './plugin/markdown/markdown.js'
            },
            {
                src: './plugin/notes/notes.js',
                async: true
            },
            {
                src: './plugin/highlight/highlight.js',
                async: true,
                callback: function () {
                    hljs.initHighlightingOnLoad();
                }
            }
        ]
    });
</script>


</body>

</html>