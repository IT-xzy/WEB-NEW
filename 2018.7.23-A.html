<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="./css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="./css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="./lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? './css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
</head>
<body>
<img src="./img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
        <section>
            <h2>gird布局</h2>

            <p>分享人: 段俊超</p>
        </section>
        <section>
            <p>目录</p>
            <p>1.背景介绍</p>
            <p>2.知识剖析</p>
            <p>3.常见问题</p>
            <p>4.解决方案</p>
            <p>5.编码实战</p>
            <p>6.参考文献</p>

        </section>
        <section>
            <section>
                <h3>1.背景介绍</h3>
            </section>
            <section>
                CSS Grid(网格) 布局（又称为 “Grid(网格)” ），
                是一个二维的基于网格的布局系统它的目标是完全改变我们基于网格的用户界面的布局方式。CSS 一直用来布局我们的网页，
                但一直以来都存在这样或那样的问题。一开始我们用表格（table），然后是浮动（float）
                ，再是定位（postion）和内嵌块（inline-block），但是所有这些方法本质上都是只是 hack 而已，并且遗漏了很多重要的功能
                （例如垂直居中）。Flexbox 的出现很大程度上改善了我们的布局方式，但它的目的是为了解决更简单的一维布局
                ，而不是复杂的二维布局（实际上 Flexbox 和 Grid 能结合在一起工作，而且配合得非常好）
                。Grid(网格) 布局是第一个专门为解决布局问题而创建的 CSS 模块，我们终于不需要想尽办法hack 页面布局样式了。
            </section>
        </section>
        <section>
            <section>
                <h3>2.知识剖析</h3>
            </section>
            <section>
                必须使用 display: grid 将容器元素定义为一个 grid(网格) 布局，
                使用  grid-template-columns 和 grid-template-rows 设置 列 和 行 的尺寸大小，
                然后通过  grid-column 和 grid-row 将其子元素放入这个 grid(网格) 中。与 flexbox 类似，网格项（grid items）的源顺序无关紧要。
                你的 CSS 可以以任何顺序放置它们，这使得使用 媒体查询（media queries）重新排列网格变得非常容易。
                定义整个页面的布局，然后完全重新排列布局以适应不同的屏幕宽度
            </section>
            <section>
                <p>重要术语</p>
                <p>1.网格容器（Grid Container）</p>
                元素应用display:grid，它是其所有网格项的父元素。下面例子container就是网格容器。
                <img src="../css/img/20180724103740.png"  alt="">
            </section>
            <section>
                <p>2.网格项（Grid Item）</p>
                网格容器的子元素，下面的item元素是网格项，但sub-item不是。
                <img src="../css/img/220180724104013.png"  alt="">
            </section>
            <section>
                <p> 3.网格线（Grid Line）</p>
                组成网格线的分界线。它们可以是列网格线（column grid lines），
                也可以是行网格线（row grid lines）并且居于行或列的任意一侧，下面黄色线就是列网格线。
                <img src="../css/img/3320180724104132.png"  alt="">
            </section>
            <section>
                <p>4.网格轨道（Grid Track）</p>
                两个相邻的网格线之间为网格轨道。你可以认为它们是网格的列或行，下面在第二个和第三个网格线之间的黄色部分为网格轨道
                <img src="../css/img/4420180724104714.png"  alt="">
            </section>
            <section>
                <p> 5.网格单元（Grid Cell）</p>
                两个相邻的列网格线和两个相邻的行网格线组成的是网格单元，它是最小的网格单元。
                下面行网格线1（row grid lines 1）、行网格线2（row grid lines 2）和列网格线1（column grid lines 1）、
                列网格线2（column grid lines2）组成的黄色区域为网格单元。
                <img src="../css/img/5520180724104921.png" alt="">
            </section>
            <section>
                <p>6.网格区（Grid Area）</p>
                网格区是由任意数量网格单元组成，下面行网格线1（row grid lines 1）、行网格线3（row grid lines 3）
                和列网格线1（column grid lines 1）、列网格线3（column grid lines3）组成的黄色区域为网格区。
                <img src="../css/img/6620180724152145.png"  alt="">
            </section>
        </section>
        <section>
            <section>
                <h3>3.常见问题</h3>
            </section>
            <section>
                <p>上手比较难</p>
            </section>
        </section>
        <section>
            <section>
                <h3>4.解决方案</h3>
            </section>
            <section>
                <a href="http://www.css88.com/archives/8506" >基本的gird布局</a>
            </section>

        </section>
        <section>
            <h3>5.编码实战</h3>
        </section>
        <section>
            <h3>6.参考文献</h3>
        </section>
        <section>
            <a href="http://peale.cn/2016/12/08/2016_12_8_grid/#more" >grid布局指南</a>
        </section>
        <section>
            <a href="http://www.css88.com/archives/8506" >快速学会grid布局</a>
        </section>
        <section>
            <h4>鸣谢</h4>
            <p>感谢大家观看</p>
            <p><small>BY:段俊超</small></p>
        </section>

    </div>
</div>

<script src="./lib/reveal/js/head.min.js"></script>
<script src="./lib/reveal/reveal.js"></script>

<script>

    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
    // 	loop: false, // 是否循环演示
    // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
    // 	fragments: true, // 全局开启和关闭碎片。
    // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
    // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
    // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
    // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
    // }

    // 初始化幻灯片
    Reveal.initialize({
        history: true,
        dependencies: [
            { src: './plugin/markdown/marked.js' },
            { src: './plugin/markdown/markdown.js' },
            { src: './plugin/notes/notes.js', async: true },
            { src: './plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
    });
</script>
</body>
</html>
