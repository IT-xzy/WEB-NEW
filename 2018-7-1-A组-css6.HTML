<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/lib/reveal/css/zenburn.css">

    <style>
        .float {
            float: left;
        }
    </style>


    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ?
            'https://ptteng.github.io/PPT/css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>

<body>
    <img src="./葡萄藤PPT_files/logo.png" alt="" usemap="#pttmap" class="base-logo">
    <map name="pttmap">
        <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com/" alt="" target="_blank">
    </map>
    <div class="reveal default center" role="application" data-transition-speed="slow" data-background-transition="fade">
        <div class="slides" style="width: 960px; height: 700px; left: 50%; top: 50%; bottom: auto; right: auto; transform: translate(-50%, -50%) scale(0.756);">
            <section class="past" style="top: 158px; display: none;" hidden="" aria-hidden="true">
                <h2>【CSS-TASK11】</h2>
                <h3>简单的了解一下sass</h3>
                <p>分享人：朱士峰</p>
            </section>
            <section class="past" style="top: 3px; display: block;" hidden="" aria-hidden="true">
                <p>目录</p>
                <p>1.背景介绍</p>
                <p>2.知识剖析</p>
                <p>3.常见问题</p>
                <p>4.解决方案</p>
                <p>5.布局示例</p>
                <p>6.扩展思考</p>
                <p>7.参考文献</p>
                <p>8.更多讨论</p>
            </section>
            <section hidden="" aria-hidden="true" class="future" style="top: 267px; display: block;">
                <h3>1.背景介绍</h3>
            </section>
            <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
                <p style="text-align: justify">
                    Sass 是一门高于 CSS 的元语言，它能用来清晰地、结构化地描述文件样式，有着比普通 CSS 更加强大的功能。 Sass 能够提供更简洁、更优雅的语法，同时提供多种功能来创建可维护和管理的样式表。 Sass 是最早的 CSS 预处理语言，有比
                    LESS 更为强大的功能，不过其一开始的缩进式语法（Sass 老版本语法，后面课程会详细介绍 ）并不能被大众接受，不过由于其强大的功能和 Ruby on Rails 的大力推动，还是有很多开发者选择了
                    Sass。 Sass 是采用 Ruby 语言编写的一款 CSS 预处理语言，它诞生于2007年，是最大的成熟的 CSS 预处理语言。最初它是为了配合 HAML（一种缩进式 HTML 预编译器）而设计的，因此有着和
                    HTML 一样的缩进式风格。
                </p>
            </section>
            <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
                <p style="text-align: justify">
                    Sass 和 SCSS 其实是同一种东西，我们平时都称之为 Sass，两者之间不同之处有以下两点： 文件扩展名不同，Sass 是以“.sass”后缀为扩展名，而 SCSS 是以“.scss”后缀为扩展名 语法书写方式不同，Sass 是以严格的缩进式语法规则来书写，不带大括号({})和分号(;)，而
                    SCSS 的语法书写和我们的 CSS 语法书写方式非常类似。
                </p>
            </section>
            <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
                <p style="text-align: justify">
                    <p> Sass 语法</p>

                    <p> $font-stack: Helvetica, sans-serif //定义变量 $primary-color: #333 //定义变量</p>

                    <p> body font: 100% $font-stack color: $primary-color
                        <p> SCSS 语法</p>

                        <p> $font-stack: Helvetica, sans-serif; $primary-color: #333;</p>
                    </p>
                    <p>
                        body { font: 100% $font-stack; color: $primary-color; }
                    </p>
                    <p> 编译出来的 CSS body { font: 100% Helvetica, sans-serif; color: #333; }</p>
                    <p> SCSS 和 CSS 写法无差别： SCSS 和 CSS 写法无差别，这也是 Sass 后来越来越受大众喜欢原因之一。简单点说，把你现有的“.css”文件直接修改成“.scss”即可使用。
                    </p>
            </section>
            <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
                <h3>2.知识剖析</h3>
            </section>
            <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
                <p style="letter-spacing: 5px">嵌套</p>
                <p style="letter-spacing: 5px">变量</p>
                <p style="letter-spacing: 5px">混合器</p>
            </section>

            <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
                <h3>1.1 嵌套CSS 规则</h3>
                <p style="letter-spacing: 5px">css中重复写选择器是非常恼人的。如果要写一大串指向页面中同一块的样式时，往往需要 一遍又一遍地写同一个ID：</p>
                <p style="letter-spacing: 5px">#content article h1 { color: #333 }</p>
                <p style="letter-spacing: 5px">#content article p { margin-bottom: 1.4em }</p>
                <p style="letter-spacing: 5px">#content aside { background-color: #EEE }</p>
                <p style="letter-spacing: 5px">像这种情况，sass可以让你只写一遍，且使样式可读性更高。在Sass中，你可以像俄罗斯套娃那样在规则块中嵌套规则块。sass在输出css时会帮你把这些嵌套规则处理好，避免你的重复书写。</p>
            </section>
            <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
                <p style="letter-spacing: 5px">#content {</p>
                <p style="letter-spacing: 5px">article {</p>
                <p style="letter-spacing: 5px">h1 { color: #333 } </p>
                <p style="letter-spacing: 5px"> p { margin-bottom: 1.4em } </p>
                <p style="letter-spacing: 5px">}</p>
                <p style="letter-spacing: 5px" aside { background-color: #EEE }></p>
                <p style="letter-spacing: 5px">}</p>
                <p style="letter-spacing: 5px">/* 编译后 */</p>
                <p style="letter-spacing: 5px">#content article h1 { color: #333 }</p>
                <p style="letter-spacing: 5px">#content article p { margin-bottom: 1.4em }</p>
                <p style="letter-spacing: 5px">#content aside { background-color: #EEE }</p>
                <p style="letter-spacing: 5px"></p>
                <p style="letter-spacing: 5px"></p>
                <p style="letter-spacing: 5px"></p>
                <p style="letter-spacing: 5px"></p>
                <p style="letter-spacing: 5px"></p>
                <p style="letter-spacing: 5px"></p>
                <p style="letter-spacing: 5px"></p>

            </section>

            <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
                <h4>1.2 父选择器的标识符&</h4>
                <p style="letter-spacing: 5px">一般情况下，sass在解开一个嵌套规则时就会把父选择器（#content）通过一个空格连接到子选择器的前边（article和aside）形成（#content article和#content aside）。这种在CSS里边被称为后代选择器，因为它选择ID为content的元素内所有命中选择器article和aside的元素。但在有些情况下你却不会希望sass使用这种后代选择器的方式生成这种连接。

                        最常见的一种情况是当你为链接之类的元素写：hover这种伪类时，你并不希望以后代选择器的方式连接。比如说，下面这种情况sass就无法正常工作：</p>
                <p style="letter-spacing: 5px">article a {</p>
                <p style="letter-spacing: 5px">color: blue;</p>
                <p style="letter-spacing: 5px">:hover { color: red }</p>
                <p style="letter-spacing: 5px">}</p>   
            </section>

            <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
                <p style="letter-spacing: 5px">这意味着color: red这条规则将会被应用到选择器article a :hover，article元素内链接的所有子元素在被hover时都会变成红色。这是不正确的！你想把这条规则应用到超链接自身，而后代选择器的方式无法帮你实现。

解决之道为使用一个特殊的sass选择器，即父选择器。在使用嵌套规则时，父选择器能对于嵌套规则如何解开提供更好的控制。它就是一个简单的&符号，且可以放在任何一个选择器可出现的地方，比如h1放在哪，它就可以放在哪。</p>
                <p style="letter-spacing: 5px">article a {</p>
                <p style="letter-spacing: 5px">color: blue;</p>
                <p style="letter-spacing: 5px">&:hover { color: red }</p>
                <p style="letter-spacing: 5px">}</p>
                <p style="letter-spacing: 5px">//编译后</p>
                <p style="letter-spacing: 5px">.selected {
                    </p>
                <p style="letter-spacing: 5px">border: 1px solid #F90;</p>
                <p style="letter-spacing: 5px">}</p>
                <p style="letter-spacing: 5px"></p>
                <p style="letter-spacing: 5px"></p>
                <p style="letter-spacing: 5px"></p>
            </section>

            <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
                    <p style="letter-spacing: 5px"></p>
                    <p style="letter-spacing: 5px"></p>
                    <p style="letter-spacing: 5px"></p>
                    <p style="letter-spacing: 5px"></p>
            </section>











            <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
                <h4>2-1 变量声明;</h4>
                <p style="letter-spacing: 5px">sass变量的声明和css属性的声明很像：</p>
                        <p style="letter-spacing: 5px">$highlight-color: #F90;</p>      
            </section>


            <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
                <p style="letter-spacing: 5px">与CSS属性不同，变量可以在css规则块定义之外存在。当变量定义在css规则块内，那么该变量只能在此规则块内使用。如果它们出现在任何形式的{...}块中（如@media或者@font-face块），情况也是如此：</p>
                <p style="letter-spacing: 5px">$nav-color: #F90;</p>
                <p style="letter-spacing: 5px">nav {</p>
                <p style="letter-spacing: 5px">$width: 100px;</p>
                <p style="letter-spacing: 5px">width: $width;</p>
                <p style="letter-spacing: 5px">color: $nav-color;</p>
                <p style="letter-spacing: 5px">}</p>
                <p style="letter-spacing: 5px">//编译后</p>
                <p style="letter-spacing: 5px">nav {</p>
                <p style="letter-spacing: 5px">width: 100px;</p>
                <p style="letter-spacing: 5px">color: #F90;</p>
                <p style="letter-spacing: 5px">}</p>
                <p style="letter-spacing: 5px"></p>
            </section>
            <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
                <h4>2-2. 变量引用</h4>
                <p style="letter-spacing: 5px">凡是css属性的标准值（比如说1px或者bold）可存在的地方，变量就可以使用。css生成时，变量会被它们的值所替代。之后，如果你需要一个不同的值，只需要改变这个变量的值，则所有引用此变量的地方生成的值都会随之改变。</p>
                <p style="letter-spacing: 5px">$highlight-color: #F90;</p>
                <p style="letter-spacing: 5px">.selected {</p>
                <p style="letter-spacing: 5px"> border: 1px solid $highlight-color;</p>
                <p style="letter-spacing: 5px">}</p>
                <p style="letter-spacing: 5px">//编译后</p>
                <p style="letter-spacing: 5px">.selected {</p>
                <p style="letter-spacing: 5px">border: 1px solid #F90;</p>
                <p style="letter-spacing: 5px">}</p>
            </section>
            <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
                <h4>3.1混合器</h4>
                <p style="letter-spacing: 5px">如果你的整个网站中有几处小小的样式类似（例如一致的颜色和字体），那么使用变量来统一处理这种情况是非常不错的选择。但是当你的样式变得越来越复杂，你需要大段大段的重用样式的代码，独立的变量就没办法应付这种情况了。你可以通过sass的混合器实现大段样式的重用。

                        混合器使用@mixin标识符定义。看上去很像其他的CSS @标识符，比如说@media或者@font-face。这个标识符给一大段样式赋予一个名字，这样你就可以轻易地通过引用这个名字重用这段样式。下边的这段sass代码，定义了一个非常简单的混合器，目的是添加跨浏览器的圆角边框。</p>
                <!-- <p style="letter-spacing: 5px">flex-end：与交叉轴的终点对齐。</p>
                <p style="letter-spacing: 5px">center：与交叉轴的中点对齐。</p>
                <p style="letter-spacing: 5px">space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</p>
                <p style="letter-spacing: 5px">space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</p>
                <p style="letter-spacing: 5px">stretch（默认值）：轴线占满整个交叉轴。</p> -->
            </section>
            <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
                <h3>3.常见问题</h3>
            </section>
            <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
                <p>如何安装sass</p>
                <!-- <p>flex的布局在熟练以后非常好用，但是pc兼容性相对较差，IE要10，甚至11以上才能要很好的兼容。</p> -->
            </section>
            <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
                <h3>4.解决方案</h3>
            </section>
            <section hidden="" aria-hidden="true" class="stack future" style="top: 330px; display: none;">
                <section style="top: 330px; display: none;">
                    <p style="text-align: center">
                        参考sass中文官网</p>
                    
                   
                </section>
            </section>
            <!-- <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
            <h3>5.编码实战</h3>
        </section> -->
            <!-- <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
            <p style="text-align: justify">1.插入纯文字。content属性与 ::before 及 ::after 伪元素配合使用生成文本内容。
            </p>
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
            <p style="text-align: justify">2.嵌入文字符号。使用content属性的open-quote属性值和close-quote属性值在字符串两边添加诸如括号、单引号、双引号之类的嵌套文字符号。open-quote用于添加开始的文字符号，close-quote用于添加结束的文字符号。
            </p>
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
            <p style="text-align: justify">3.插入图片。content属性也可以直接在元素前/后插入图片， content:url()。
            </p>
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
            <p style="text-align: justify">4.插入元素的属性值。content属性可以直接利用attr获取元素的属性，将其插入到对应位置。
                attr（attribute），是属性的意思，attr(href)，也就是获取href里面的值填充到content里面啊，这是css3的用法。
                语法为::after{content:attr(href);}
            </p>
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
            <p style="text-align: justify">5.计数器用法。content属性可以插入编号，可以修饰，可以指定编号种类，还可以在编号中进行嵌套。
            </p>
        </section> -->
            <!-- <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
            <h3>6.扩展思考</h3>
        </section> -->
            <!-- <section hidden="" aria-hidden="true" class="stack future" style="top: 330px; display: none;">
            <section style="top: 330px; display: none;">
                <p style="text-align: center">
                    content:"."是怎么实现清除浮动的？
                </p>
            </section>
        </section>
        <section hidden="" aria-hidden="true" class="stack future" style="top: 330px; display: none;">
            <section style="top: 330px; display: none;">
                <p style="text-align: center">
                    如果有一个DIV作为外部容器，内部的DIV如果设置了float样式，则外部的容器DIV因为内部没有clear，导致不能被撑开。
                    这个对这个盒子使用：：after这个伪元素，在盒子的结尾添加content属性，添加了一个句号"."，
                    并设置display为block；高度设为0；clear设为both；visibility设为隐藏。这样就达到了撑开容器的目的。
                </p>
            </section> -->
            </section>
            <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
                <h3>7.参考文献</h3>
            </section>
            <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
                <p>参考一：
                    <a href="https://www.sass.hk/guide/" target="_blank">
                        CSS3的flex属性详解</a>
                </p>
            </section>
            <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
                <h3>8.更多讨论</h3>
            </section>
            <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
                <h4>鸣谢</h4>
                <p>感谢大家观看</p>
                <p>
                    <small>BY :黄志波|罗宇|冯馨雨|隋鑫|徐炜</small>
                </p>
            </section>

        </div>
        <div class="backgrounds">
            <div class="slide-background past" data-loaded="true" style="display: none;"></div>
            <div class="slide-background past" data-loaded="true" style="display: block;"></div>
            <div class="slide-background past" data-loaded="true" style="display: block;"></div>
            <div class="slide-background stack present" data-loaded="true" style="display: block;">
                <div class="slide-background past" data-loaded="true" style="display: block;"></div>
                <div class="slide-background present" data-loaded="true" style="display: block;"></div>
            </div>
            <div class="slide-background future" data-loaded="true" style="display: block;"></div>
            <div class="slide-background future" data-loaded="true" style="display: block;"></div>
            <div class="slide-background future" data-loaded="true" style="display: none;"></div>
            <div class="slide-background future" data-loaded="true" style="display: none;"></div>
            <div class="slide-background future" style="display: none;"></div>
            <div class="slide-background stack future" style="display: none;">
                <div class="slide-background present" style="display: none;"></div>
            </div>
            <div class="slide-background future" style="display: none;"></div>
            <div class="slide-background stack future" style="display: none;">
                <div class="slide-background present" style="display: none;"></div>
            </div>
            <div class="slide-background future" style="display: none;"></div>
            <div class="slide-background stack future" style="display: none;">
                <div class="slide-background present" style="display: none;"></div>
            </div>
            <div class="slide-background stack future" style="display: none;">
                <div class="slide-background present" style="display: none;"></div>
                <div class="slide-background future" style="display: none;"></div>
                <div class="slide-background future" style="display: none;"></div>
            </div>
            <div class="slide-background future" style="display: none;"></div>
            <div class="slide-background future" style="display: none;"></div>
            <div class="slide-background future" style="display: none;"></div>
            <div class="slide-background future" style="display: none;"></div>
        </div>
        <div class="progress" style="display: block;">
            <span style="width: 260.19px;"></span>
        </div>
        <aside class="controls" style="display: block;">
            <button class="navigate-left enabled" aria-label="previous slide"></button>
            <button class="navigate-right enabled" aria-label="next slide"></button>
            <button class="navigate-up enabled" aria-label="above slide"></button>
            <button class="navigate-down" aria-label="below slide"></button>
        </aside>
        <div class="slide-number" style="display: none;"></div>
        <div class="speaker-notes" data-prevent-swipe=""></div>
        <div class="pause-overlay"></div>
        <div id="aria-status-div" aria-live="polite" aria-atomic="true" style="position: absolute; height: 1px; width: 1px; overflow: hidden; clip: rect(1px, 1px, 1px, 1px);">

            语法： return[()[expression][]]; 可选项 expression 参数是要从函数返回的值。如果省略，则该函数不返回值。 用 return 语句来终止一个函数的执行，并返回 expression 的值。如果 expression
            被省略， 或在函数内没有 return 语句被执行，则把值 undefined 赋给调用当前函数的表达式。
        </div>
    </div>

    <script src="https://ptteng.github.io/PPT/lib/reveal/js/head.min.js"></script>
    <script src="https://ptteng.github.io/PPT/lib/reveal/reveal.js"></script>

    <script>
        // 以下为常见配置属性的默认值
        // {
        // 	controls: true, // 是否在右下角展示控制条
        // 	progress: true, // 是否显示演示的进度条
        // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
        // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
        // 	keyboard: true, // 是否启用键盘快捷键来导航
        // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
        // 	center: true, // 是否将幻灯片垂直居中
        // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
        // 	loop: false, // 是否循环演示
        // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
        // 	fragments: true, // 全局开启和关闭碎片。
        // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
        // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
        // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
        // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
        // }

        // 初始化幻灯片
        Reveal.initialize({
            //        history: true,
            transition: 'default',
            transitionSpeed: 'slow',
            dependencies: [{
                    src: '../plugin/markdown/marked.js'
                },
                {
                    src: '../plugin/markdown/markdown.js'
                },
                {
                    src: '../plugin/notes/notes.js',
                    async: true
                },
                {
                    src: '../plugin/highlight/highlight.js',
                    async: true,
                    callback: function () {
                        hljs.initHighlightingOnLoad();
                    }
                }
            ]
        });
        //    原始类型对象直接赋值不会相互影响
        //    var a = 1;
        //
        //    var b = a;
        //    b = 10;
        //    console.log(a); // 1
        ////
        //    var a = 'hello';
        //    var b = a;
        //    b = 'world';
        //    console.log(a); // hello
        //
        //    var a = true;
        //    var b = a;
        //    b = false;
        //    console.log(a);

        //数组浅复制
        //    var a = ['隔壁老王','冠希哥', '宋经理' //定义一个名为a的属猪，里面有3个值，
        //    ];
        //    var b = a;   //定义一个变量b，把a赋值给他，这样比、b和a一样了
        //    b[2] = '冲冲老师'; //然后把b的第三个值等于冲冲老师
        //    console.log(a)//那么现在打印a 是什么结果呢
        //
        //    var arr = ["One","Two","Three"];   //数组的深复制，slice方法
        //    var arrtoo = arr.slice(1);
        //    arrtoo[2] = "set Map";
        //    console.log(arr);//One,Two,Three
        //    console.log(arrtoo);//One,set Map,Three

        //
        //    var arr1 = ["One","Two","Three"]; //数组的深复制，concat 方法
        //    var arrtooo = arr1.concat(111111);
        //    arrtooo[1] = "set Map To";
        //    console.log(arr1);//One,Two,Three
        //    console.log(arrtooo);//One,set Map To,Three

        //
        //    var b=[1,2,3,4,5];   //concat的链接
        //    var c=[6,7,8,9];
        //    var d =[4,4,22]
        //    console.log(b.concat(c,d))

        var a = {
            name: 'yy',
            age: 26
        }; //对象的浅拷贝哦
        var b = new Object();
        b.name = a.name;
        b.age = a.age;
        b.name = 'xx';
        console.log(a); //Object { name="yy", age=26}
        console.log(b); //Object { name="xx", age=26}

        var d = { //对象的浅拷贝哦 第一种
            name: 'd',
            oc: {
                age: 32
            },
            oad: {
                adds: {
                    bb: 12
                }
            }
        };
        var deepCopy = function (source) {
            var result = {};
            for (var key in source) {
                result[key] = typeof source[key] === 'object' ? deepCopy(source[key]) : source[key]
            }
            return result
        };

        var c = deepCopy(d);
        c.name = 'c';
        c.oc = {
            age: 49
        };
        console.log(c);
        console.log(d);


        //    var person = {    //第二种深拷贝
        //        name: 'aa',
        //        friends: ['da', 'dsa', 'gf']
        //    };
        //
        //    var aPerson = Object.create(person, {
        ////        name: {
        ////            value: "gee"
        ////        }
        //    });
        //
        //    console.log(person.name);
        //    console.log(aPerson.friends)

        var Chinese = {
            nation: '中国'

        }
        var Doctor = {
            career: '医生'
        }

        function extendCopy(p) {
            var c = {};
            for (var i in p) {
                c[i] = p[i];
            }
            c.uber = p;
            return c;
        }

        var Doctor = extendCopy(Chinese);
        Doctor.career = '医生';
        console.log(Doctor); // 中国
        Chinese.birthPlaces = ['北京', '上海', '香港'];
        var Doctor = extendCopy(Chinese);
        Doctor.birthPlaces.push('厦门');
    </script>

</body>

</html>